from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from fastapi.responses import FileResponse
from pydantic import BaseModel, Field
from langchain_core.messages import HumanMessage, AIMessage
from agent_runnable import init_app, config  # ✅ import init_app instead of app
import traceback
import sys
import os

app_fastapi = FastAPI()

# Enable CORS
app_fastapi.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Change in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"]
)

agent_app = None  # ✅ define agent_app globally

@app_fastapi.on_event("startup")
async def startup_event():
    global agent_app
    agent_app = await init_app()  # ✅ initialize app at startup

# Define input schema
class UserInput(BaseModel):
    message: str = Field(..., min_length=1, description="User message")
    patient_id: str | None = Field(None, description="Unique patient ID")
    patient_name: str | None = Field(None, description="Full name of the patient")

@app_fastapi.post("/chat")
async def chat_endpoint(user_input: UserInput):
    global agent_app
    if agent_app is None:
        raise HTTPException(status_code=500, detail="Agent not initialized yet.")

    message = user_input.message.strip()
    if not message:
        raise HTTPException(status_code=400, detail="Message cannot be empty.")

    # Initial patient name/id collection
    if not user_input.patient_name:
        return {"response": "Hello! Please enter your full name."}
    if not user_input.patient_id:
        return {"response": f"Thanks {user_input.patient_name}, now enter your Patient ID."}

    state = {
        "messages": [HumanMessage(content=message)],
        "patient_name": user_input.patient_name,
        "rewrite_count": 0,
        "patient_id": user_input.patient_id,
    }

    try:
        thread_id = user_input.patient_id
        config_with_thread = {"configurable": {"thread_id": thread_id}}

        response_chunks = []

        # ✅ Use async streaming to avoid InvalidStateError with AsyncSqliteSaver
        events = agent_app.astream(state, config=config_with_thread, stream_mode="values")

        async for event in events:
            if not event.get("messages"):
                continue
            last_msg = event["messages"][-1]
            if isinstance(last_msg, AIMessage):
                content = last_msg.content
                if isinstance(content, dict):
                    response_chunks.append(content.get("content", str(content)))
                elif isinstance(content, str):
                    response_chunks.append(content.strip())

        if not response_chunks:
            raise HTTPException(status_code=500, detail="No response generated by the agent.")

        response = " ".join(response_chunks).strip()
        return {"response": response}

    except Exception as e:
        traceback.print_exc(file=sys.stdout)
        raise HTTPException(status_code=500, detail=f"Agent error: {str(e)}")

# Mount static files directory
app_fastapi.mount("/static", StaticFiles(directory="."), name="static")

@app_fastapi.get("/")
def root():
    return {"status": "Hospital agent is running."}

@app_fastapi.get("/chatbot.html")
async def get_chatbot():
    return FileResponse("chatbot.html")
